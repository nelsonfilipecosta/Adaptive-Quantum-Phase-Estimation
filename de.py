import numpy as np
import random
import statistics
import generate
import aqem


def evolution(K, N, P, G, R, threshold, F, C, phi, input, mu, sigma, loss, visibility):

    '''Differential Evolution. This function returns the best policy generated by the DE algorithm.'''

    policy = np.array([np.array([np.array([0. for i in range(N)]) for j in range(P)]) for k in range(G)])
    mutation = np.array([np.array([np.array([0. for i in range(N)]) for j in range(P)]) for k in range(G)])
    crossover = np.array([np.array([np.array([0. for i in range(N)]) for j in range(P)]) for k in range(G)])

    for i in range(P):
        policy[0][i] = np.array(generate.policy(N))

    gbest = 0
    aux_best = 1000

    count = 0

    for g in range(G-1):
        
        print("Geneneration: ", g)

        aux_counter = 0
        
        for i in range(P):
                       
            rand = random.sample(range(0,P-1), 5)

            rand_n = random.randint(0,N-1)
            rand_j = [random.uniform(0, 1) for i in range(N)]

            aux_dif = np.array([0. for j in range(N)])

            for j in range(N):
                
                aux_dif[j] = (policy[g][rand[1]][j] + policy[g][rand[2]][j] - policy[g][rand[3]][j] - policy[g][rand[4]][j]) / 2

                if aux_dif[j] >= 2*np.pi:
                    a = aux_dif[j]
                    b = a // (2*np.pi)
                    aux_dif[j] = a - 2*b*np.pi
                
                if aux_dif[j] <= -2*np.pi:
                    a = aux_dif[j]
                    b = a // (2*np.pi) + 1
                    aux_dif[j] = a - 2*b*np.pi

                if aux_dif[j] > 1*np.pi:
                    aux_dif[j] = aux_dif[j] - 2*np.pi

                if aux_dif[j] < -1*np.pi:
                    aux_dif[j] = aux_dif[j] + 2*np.pi

            if g == 0:
                mutation[g+1][i] = policy[g][rand[0]] + F * aux_dif
            
            if g > 0:
                mutation[g+1][i] = policy[g][gbest] + F * aux_dif                                                           
                
            for j in range(N):

                if rand_j[j] <= C or j == rand_n:
                    crossover[g+1][i][j] = mutation[g+1][i][j]

                    if crossover[g+1][i][j] < 0:
                        a = abs(crossover[g+1][i][j])
                        b = a // (2*np.pi) + 1
                        crossover[g+1][i][j] = 2*b*np.pi - a

                    if crossover[g+1][i][j] >= 2*np.pi:
                        a = crossover[g+1][i][j]
                        b = a // (2*np.pi)
                        crossover[g+1][i][j] = a - 2*b*np.pi

                if rand_j[j] > C and j != rand_n:
                    crossover[g+1][i][j] = policy[g][i][j]

            target_variance = aqem.simulate(K, N, R, phi, input, policy[g][i], mu, sigma, loss, visibility)
            trial_variance = aqem.simulate(K, N, R, phi, input, crossover[g+1][i], mu, sigma, loss, visibility)

            if trial_variance <= target_variance:
                policy[g+1][i] = crossover[g+1][i]
                aux_best2 = trial_variance
            
            if trial_variance > target_variance:
                policy[g+1][i] = policy[g][i]
                aux_best2 = target_variance
            
            if aux_best2 < aux_best:
                aux_best = aux_best2
                gbest = i

        count = count + 1

        c = np.array([0. for i in range(N)])
        s = np.array([0. for i in range(N)])

        for i in range(P):
            for j in range(N):
                c[j] = c[j] + np.real(np.cos(policy[g][i][j])) / P
                s[j] = s[j] + np.real(np.sin(policy[g][i][j])) / P

        best_policy = np.array([0. for i in range(N)])

        for i in range(N):
            if c[i] > 0 and s[i] > 0:
                best_policy[i] = np.real(np.arctan(s[i]/c[i]))
            if c[i] < 0:
                best_policy[i] = np.real(np.arctan(s[i]/c[i]) + 1*np.pi)
            if c[i] > 0 and s[i] < 0:
                best_policy[i] = np.real(np.arctan(s[i]/c[i]) + 2*np.pi)

        
        dispersion = np.array([0. for i in range(N)])

        for i in range(N):
            for j in range(P):

                if abs(best_policy[i] - policy[g][j][i]) < 1*np.pi:
                    dispersion[i] = dispersion[i] + abs(best_policy[i] - policy[g][j][i])                                 
            
                else:
                    dispersion[i] = dispersion[i] + 2*np.pi - abs(best_policy[i] - policy[g][j][i])

            dispersion[i] = dispersion[i] / P

            if dispersion[i] < threshold * 2*np.pi:
                aux_counter = aux_counter + 1

        if aux_counter == N:
            break

    if count < G-1:
        print("The algorithm converged in", count, "iterations.\n")
    
    else:
        print("The algorithm didn't converge in", G, "iterations.\n")
    
    dispersion_avg = statistics.mean(dispersion)

    dispersion_std = statistics.stdev(dispersion)

    print("Dispersion Average: ", dispersion_avg, "  Dispersion Standard Deviation: ", dispersion_std, "\n")

    return best_policy